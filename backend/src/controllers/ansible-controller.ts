import { exec } from 'child_process';
import { ElasticNode } from '../interfaces';
import { Playbook } from 'node-ansible';
import fs from 'fs';
import path from 'path';

export const createAnsibleInventory = async (
  nodes: ElasticNode[],
  pathToKey: string,
) => {
  try {
    const roleGroups: Record<
      'elasticsearch_master' | 'elasticsearch_data',
      string[]
    > = {
      elasticsearch_master: [],
      elasticsearch_data: [],
    };

    for (const node of nodes) {
      console.log(node);
      if (node.isMaster === true) {
        roleGroups.elasticsearch_master.push(
          `${node.name} ansible_host=${node.ip}`,
        );
        continue;
      }
      if (node.roles.includes('data')) {
        roleGroups.elasticsearch_data.push(
          `${node.name} ansible_host=${node.ip}`,
        );
      }
    }
    ///Right now adding all master_eligible into master once the playbooks are updated to consider master eligible nodes this part of code must also be updated

    const inventoryParts: string[] = [];

    Object.entries(roleGroups).forEach(([group, hosts]) => {
      if (hosts.length > 0) {
        inventoryParts.push(`[${group}]\n${hosts.join('\n')}`);
      }
    });

    inventoryParts.push(
      `[elasticsearch:children]\n${Object.keys(roleGroups)
        .filter(
          (group) => group.length > 0 && group.startsWith('elasticsearch_'),
        )
        .join('\n')}`,
    );

    //   inventoryParts.push(
    //     `[kibana:vars]\nansible_ssh_user=ubuntu\nansible_ssh_private_key_file=/SSH/File/Path/HF-EC2-key.pem`
    //   );
    inventoryParts.push(
      `[elasticsearch:vars]\nansible_ssh_user=ubuntu\nansible_ssh_private_key_file=${pathToKey}`,
    );
  } catch (error) {
    console.error('Error creating Ansible inventory:', error);
  }
};

/**
 * Executes an Ansible playbook using node-ansible.
 *
 * @param inventoryPath - Path to the inventory file.
 * @param elkVersion - Version of ELK to use as an extra variable.
 * @param playbookName - Name of the playbook file to execute.
 * @returns A Promise that resolves with the logs generated by the playbook execution.
 */
export const executeAnsiblePlaybook = async (
  inventoryPath: string,
  elkVersion: string,
  playbookName: string,
  username: string,
  password: string,
): Promise<string> => {
  // Resolve absolute paths
  const inventoryFile = path.resolve(inventoryPath);
  const playbookFile = path.resolve(playbookName);

  // Configure the Ansible playbook command
  const playbook = new Playbook().playbook(playbookFile);

  // Set inventory file
  playbook.inventory(inventoryFile);

  // Pass extra variables
  playbook.variables({ elk_version: elkVersion, username: username, password });

  try {
    // Execute the playbook
    const result = await playbook.exec();
    console.log(result);

    // Check for success and return logs
    if (result.code === 0) {
      console.log('Ansible playbook executed successfully.');
      return result.output; // Contains logs of execution
    } else {
      console.error('Ansible playbook failed:', result.stderr);
      throw new Error(
        `Playbook failed with exit code ${result.code}: ${result.stderr}`,
      );
    }
  } catch (error) {
    console.error('Error running Ansible playbook:', error);
    throw new Error(`Error executing playbook: ${(error as Error).message}`);
  }
};
